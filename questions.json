{
    "categories": [
      { "id": "databases", "name": "Bazy Danych", "icon": "ğŸ—„ï¸" },
      { "id": "programing", "name": "Programowanie", "icon": "ğŸ’»" }
    ],
    "flashcards": [
      {
        "category": "databases", "front": "Postulat Codd'a: Gwarancja dostÄ™pu",
        "back": "Do kaÅ¼dej pojedynczej danej w bazie moÅ¼na siÄ™ odwoÅ‚aÄ‡ przez kombinacjÄ™: nazwa tabeli + nazwa kolumny + wartoÅ›Ä‡ klucza gÅ‚Ã³wnego."
      },
      {
        "category": "databases", "front": "WartoÅ›Ä‡ NULL",
        "back": "Reprezentuje brak danych lub wartoÅ›Ä‡ nieznanÄ…. RÃ³Å¼ni siÄ™ od cyfry zero czy pustego ciÄ…gu znakÃ³w."
      },
      {
        "category": "databases", "front": "NiezaleÅ¼noÅ›Ä‡ danych (Logiczna vs Fizyczna)",
        "back": "Fizyczna: Zmiany na dysku nie wpÅ‚ywajÄ… na aplikacjÄ™. Logiczna: Zmiany struktury tabel (jeÅ›li zachowujÄ… info) nie psujÄ… aplikacji."
      },
      {
        "category": "databases", "front": "Klucz gÅ‚Ã³wny (PRIMARY KEY)",
        "back": "Jednoznacznie identyfikuje kaÅ¼dy wiersz w tabeli. Nie moÅ¼e zawieraÄ‡ wartoÅ›ci NULL i musi byÄ‡ unikalny."
      },
      {
        "category": "databases", "front": "Klucz obcy (FOREIGN KEY)",
        "back": "Gwarantuje spÃ³jnoÅ›Ä‡ referencyjnÄ…. WartoÅ›Ä‡ musi istnieÄ‡ jako klucz gÅ‚Ã³wny w tabeli nadrzÄ™dnej lub przyjÄ…Ä‡ wartoÅ›Ä‡ NULL."
      },
      {
        "category": "databases", "front": "Encja silna vs Encja sÅ‚aba",
        "back": "Silna moÅ¼e istnieÄ‡ samodzielnie w bazie. SÅ‚aba zaleÅ¼y od innej encji (np. encja asocjacyjna dla relacji wiele-do-wiele)."
      },
      {
        "category": "databases", "front": "Pierwsza PostaÄ‡ Normalna (1NF)",
        "back": "Wymaga atomowoÅ›ci wartoÅ›ci (brak list w jednej komÃ³rce), braku powtarzajÄ…cych siÄ™ grup oraz posiadania unikalnego klucza."
      },
      {
        "category": "databases", "front": "RozwiÄ…zywanie relacji wiele-do-wiele (M:N)",
        "back": "Relacyjny model tego nie obsÅ‚uguje. NaleÅ¼y jÄ… rozbiÄ‡ na dwie relacje 1:N i utworzyÄ‡ dodatkowÄ… encjÄ™ asocjacyjnÄ… (tabelÄ™ Å‚Ä…czÄ…cÄ…)."
      },
      {
        "category": "databases", "front": "ReguÅ‚y transakcji (ACID)",
        "back": "A - AtomowoÅ›Ä‡ (wszystko albo nic), C - SpÃ³jnoÅ›Ä‡ (logiczna poprawnoÅ›Ä‡), I - Izolacja (brak wpÅ‚ywu innych), D - TrwaÅ‚oÅ›Ä‡ (odpornoÅ›Ä‡ na awarie)."
      },
      {
        "category": "databases", "front": "Anomalia: Dirty Read (Odczyt niezatwierdzonych danych)",
        "back": "Odczytanie przez transakcjÄ™ danych, ktÃ³re zostaÅ‚y zmienione przez innÄ… transakcjÄ™, ale nie zostaÅ‚y jeszcze zatwierdzone (COMMIT)."
      },
      {
        "category": "databases", "front": "Anomalia: Non-repeatable Read (Niepowtarzalny odczyt)",
        "back": "Ponowny odczyt tego samego rekordu w jednej transakcji daje inny wynik, bo inna transakcja w miÄ™dzyczasie go zmodyfikowaÅ‚a."
      },
      {
        "category": "databases", "front": "Anomalia: Phantom Read (Fantom)",
        "back": "Sytuacja, w ktÃ³rej podczas zapytania inna transakcja dodaje do tabeli nowe wiersze speÅ‚niajÄ…ce kryteria tego zapytania."
      },
      {
        "category": "databases", "front": "Blokada WspÃ³Å‚dzielona (S) vs WyÅ‚Ä…czna (X)",
        "back": "S (Shared) - pozwala innym na odczyt, ale blokuje zapis. X (Exclusive) - daje wyÅ‚Ä…czny dostÄ™p, blokuje odczyt i zapis dla innych."
      },
      {
        "category": "databases", "front": "Mechanizm Migawek (Snapshots / MVCC)",
        "back": "Transakcja pracuje na staÅ‚ym obrazie danych z momentu jej rozpoczÄ™cia. DziÄ™ki wielowersyjnoÅ›ci odczyty nie blokujÄ… zapisÃ³w."
      },
      {
        "category": "databases", "front": "DQL, DML, DDL, DCL",
        "back": "DQL (SELECT), DML (INSERT/UPDATE/DELETE), DDL (CREATE/ALTER/DROP), DCL (GRANT/REVOKE)."
      },
      {
        "category": "databases", "front": "Rozszerzenia proceduralne SQL",
        "back": "T-SQL dla MS SQL Server oraz PL/SQL dla Oracle DB. PozwalajÄ… pisaÄ‡ skrypty z uÅ¼yciem zmiennych, pÄ™tli i instrukcji warunkowych IF."
      },
      {
        "category": "databases", "front": "Indeks pogrupowany (Clustered)",
        "back": "Definiuje fizyczne uporzÄ…dkowanie danych na dysku. LiÅ›cie indeksu to same dane. W tabeli moÅ¼e byÄ‡ tylko jeden taki indeks."
      },
      {
        "category": "databases", "front": "Indeks niepogrupowany (Non-clustered)",
        "back": "Dane nie sÄ… uporzÄ…dkowane fizycznie. Indeks przechowuje jedynie wskaÅºniki (adresy) do konkretnych wierszy. MoÅ¼e ich byÄ‡ wiele."
      },
      {
        "category": "databases", "front": "Strategia â€tylko indeksâ€ (Covering Index / Included Columns)",
        "back": "Indeks zawiera wszystkie kolumny potrzebne do wykonania zapytania, dziÄ™ki czemu serwer w ogÃ³le nie musi zaglÄ…daÄ‡ do wÅ‚aÅ›ciwej tabeli z danymi."
      },
      {
        "category": "databases", "front": "Konserwacja indeksÃ³w: REORGANIZE vs REBUILD",
        "back": "REORGANIZE to lÅ¼ejsza i szybsza operacja na poziomie liÅ›ci. REBUILD to caÅ‚kowite przebudowanie indeksu od zera, znoszÄ…ce fragmentacjÄ™ w 100%."
      },
      {
        "category": "databases", "front": "Antywzorzec wydajnoÅ›ciowy w klauzuli WHERE",
        "back": "UÅ¼ywanie funkcji na kolumnie indeksowanej (np. WHERE pensja * 12 = 12000). Powoduje to odrzucenie indeksu i skanowanie caÅ‚ej tabeli (Table Scan)."
      },
      {
        "category": "databases", "front": "WiÄ™zy CHECK",
        "back": "Ograniczenie (constraint) pozwalajÄ…ce zdefiniowaÄ‡ dopuszczalny zakres lub format wartoÅ›ci dla danej kolumny (np. wiek > 0)."
      },
      {
        "category": "databases", "front": "WiÄ™zy UNIQUE",
        "back": "ZapewniajÄ… unikalnoÅ›Ä‡ wartoÅ›ci w kolumnie. W przeciwieÅ„stwie do PRIMARY KEY, zazwyczaj dopuszczajÄ… przechowywanie wartoÅ›ci NULL."
      },
      {
        "category": "databases", "front": "Architektura Klient-Serwer: Rola Serwera",
        "back": "Przechowuje dane, wykonuje instrukcje SQL, dba o spÃ³jnoÅ›Ä‡ danych oraz zarzÄ…dza uprawnieniami uÅ¼ytkownikÃ³w."
      },
      {
        "category": "databases", "front": "Architektura Klient-Serwer: Rola Klienta",
        "back": "Zapewnia interfejs uÅ¼ytkownika (UI) i przesyÅ‚a zlecenia w postaci zapytaÅ„ SQL do serwera."
      },
      {
        "category": "databases", "front": "LicznoÅ›Ä‡ zwiÄ…zku (Cardinality)",
        "back": "OkreÅ›la zasady powiÄ…zaÅ„ miÄ™dzy encjami na diagramie ERD, np. jeden-do-jednego (1:1), jeden-do-wielu (1:N), wiele-do-wielu (M:N)."
      },
      {
        "category": "databases", "front": "NarzÄ™dzia CASE (np. Visio, Vertabelo)",
        "back": "SÅ‚uÅ¼Ä… do rysowania diagramÃ³w ERD i potrafiÄ… zautomatyzowaÄ‡ pracÄ™, tÅ‚umaczÄ…c graf na gotowy skrypt SQL generujÄ…cy tabele."
      },
      {
        "category": "databases", "front": "Modelowanie struktur hierarchicznych",
        "back": "Wykorzystuje siÄ™ do tego zwiÄ…zki rekurencyjne (tabela odwoÅ‚uje siÄ™ kluczem obcym sama do siebie, np. szef-pracownik)."
      },
      {
        "category": "databases", "front": "Modelowanie historii (Encje temporalne)",
        "back": "SposÃ³b na Å›ledzenie zmian w czasie (np. historii pensji). Tworzy siÄ™ encjÄ™ zaleÅ¼nÄ…, a do jej klucza gÅ‚Ã³wnego dodaje siÄ™ atrybut czasu (np. Data_od)."
      },
      {
        "category": "databases", "front": "Zasada ACID: AtomowoÅ›Ä‡",
        "back": "Wszystkie instrukcje w ramach transakcji sÄ… wykonywane w caÅ‚oÅ›ci, albo nie jest wykonywana Å¼adna z nich (wszystko albo nic)."
      },
      {
        "category": "databases", "front": "Zasada ACID: SpÃ³jnoÅ›Ä‡",
        "back": "Po zakoÅ„czeniu transakcji baza danych musi pozostaÄ‡ w stanie spÃ³jnym logicznie (nie moÅ¼e Å‚amaÄ‡ wiÄ™zÃ³w integralnoÅ›ci)."
      },
      {
        "category": "databases", "front": "Zasada ACID: Izolacja",
        "back": "Transakcja wykonuje siÄ™ tak, jakby byÅ‚a jedyna w systemie. UÅ¼ytkownik nie powinien odczuwaÄ‡, Å¼e w tle dziaÅ‚ajÄ… inne procesy."
      },
      {
        "category": "databases", "front": "Zasada ACID: TrwaÅ‚oÅ›Ä‡",
        "back": "Raz zatwierdzone zmiany (COMMIT) muszÄ… przetrwaÄ‡ wszelkie ewentualne awarie systemu (np. brak prÄ…du)."
      },
      {
        "category": "databases", "front": "Poziom izolacji: Read Uncommitted",
        "back": "NajniÅ¼szy poziom. Dopuszcza wszystkie anomalie wspÃ³Å‚bieÅ¼noÅ›ci, wÅ‚Ä…cznie z czytaniem brudnych (niezatwierdzonych) danych."
      },
      {
        "category": "databases", "front": "Poziom izolacji: Read Committed",
        "back": "DomyÅ›lny poziom np. w MS SQL. Blokuje odczyt niezatwierdzonych danych, ale dopuszcza niepowtarzalne odczyty i fantomy."
      },
      {
        "category": "databases", "front": "Poziom izolacji: Repeatable Read",
        "back": "Gwarantuje, Å¼e odczytany raz wiersz nie zmieni siÄ™ do koÅ„ca transakcji, jednak wciÄ…Å¼ mogÄ… pojawiÄ‡ siÄ™ nowe wiersze (fantomy)."
      },
      {
        "category": "databases", "front": "Poziom izolacji: Serializable",
        "back": "NajwyÅ¼szy i najbezpieczniejszy poziom izolacji. CaÅ‚kowicie eliminuje fantomy, ale mocno obciÄ…Å¼a wydajnoÅ›Ä‡ (duÅ¼o blokad)."
      },
      {
        "category": "databases", "front": "Perspektywy (Widoki / VIEW)",
        "back": "Wirtualne tabele oparte na zapisanym zapytaniu SELECT. UÅ‚atwiajÄ… ukrycie skomplikowanych zÅ‚Ä…czeÅ„ (JOIN) lub ograniczajÄ… dostÄ™p do wraÅ¼liwych kolumn."
      },
      {
        "category": "databases", "front": "Podzapytania skorelowane (Correlated Subqueries)",
        "back": "ZagnieÅ¼dÅ¼one zapytania, ktÃ³re w swoim warunku (WHERE) odwoÅ‚ujÄ… siÄ™ do danych z zapytania nadrzÄ™dnego (gÅ‚Ã³wnego)."
      },
      {
        "category": "databases", "front": "Kiedy NIE warto stosowaÄ‡ indeksÃ³w?",
        "back": "Na bardzo maÅ‚ych tabelach, na tabelach poddawanych ciÄ…gÅ‚ym aktualizacjom (INSERT/UPDATE) oraz na kolumnach o maÅ‚ej unikalnoÅ›ci danych (np. pÅ‚eÄ‡)."
      },
      {
        "category": "databases", "front": "Analiza planu wykonania (Execution Plan)",
        "back": "Pozwala sprawdziÄ‡, czy optymalizator uÅ¼ywa indeksu (szybki Index Seek), czy wymusza powolne skanowanie caÅ‚ej tabeli (Table Scan)."
      },
      {
        "category": "databases", "front": "PielÄ™gnacja: Aktualizacja statystyk",
        "back": "Optymalizator zapytaÅ„ SQL musi znaÄ‡ aktualny rozkÅ‚ad danych w tabeli, aby trafnie decydowaÄ‡, czy uÅ¼yÄ‡ indeksu, czy peÅ‚nego skanowania."
      },
      {
        "category": "databases", "front": "Fundament relacyjnego modelu danych",
        "back": "Opiera siÄ™ na matematycznym pojÄ™ciu relacji, ktÃ³ra jest podzbiorem iloczynu kartezjaÅ„skiego zbiorÃ³w."
      },
      {
        "category": "databases", "front": "Logiczna reprezentacja: Tabele, Kolumny, Wiersze",
        "back": "W modelu relacyjnym dane to tabele. Kolumny (pola) odpowiadajÄ… atrybutom relacji, a wiersze (rekordy) to instancje/elementy relacji."
      },
      {
        "category": "databases", "front": "WartoÅ›ci atomowe (1NF)",
        "back": "Dane na poziomie logicznym sÄ… reprezentowane wyÅ‚Ä…cznie za pomocÄ… wartoÅ›ci niepodzielnych. Brak tablic czy zagnieÅ¼dÅ¼onych list w jednej komÃ³rce."
      },
      {
        "category": "databases", "front": "WiÄ™zy integralnoÅ›ci (SpÃ³jnoÅ›Ä‡ danych)",
        "back": "ReguÅ‚y definiowane na etapie projektowania bazy (np. PK, FK, CHECK). Za ich bezwzglÄ™dne przestrzeganie odpowiada silnik bazy danych (SZBD)."
      },
      {
        "category": "databases", "front": "WiÄ™zy NOT NULL",
        "back": "Ograniczenie zakazujÄ…ce pozostawiania pustych pÃ³l w danej kolumnie (wymusza wprowadzenie jakiejkolwiek wartoÅ›ci)."
      },
      {
        "category": "databases", "front": "OpcjonalnoÅ›Ä‡ zwiÄ…zku (Diagramy ERD)",
        "back": "OkreÅ›la, czy powiÄ…zanie miÄ™dzy dwiema encjami jest bezwzglÄ™dnie wymagane, czy dopuszcza brak powiÄ…zania (wartoÅ›ci NULL w kluczu obcym)."
      },
      {
        "category": "databases", "front": "Funkcje diagramÃ³w ERD",
        "back": "NarzÄ™dzie komunikacji (zrozumienie biznesu), abstrakcja (pomijanie detali fizycznych) i automatyzacja (narzÄ™dzia CASE generujÄ…ce kod SQL)."
      },
      {
        "category": "databases", "front": "Transakcja (Definicja)",
        "back": "CiÄ…g operacji odczytu i zapisu danych, ktÃ³ry z punktu widzenia logiki aplikacji stanowi jednÄ… niepodzielnÄ… caÅ‚oÅ›Ä‡."
      },
      {
        "category": "databases", "front": "Blokady typu U (Update) i I (Intent)",
        "back": "U (Update) zapobiega zakleszczeniom przy chÄ™ci modyfikacji. I (Intent) to blokady na wyÅ¼szych poziomach (np. tabeli) sygnalizujÄ…ce blokady niÅ¼ej (w wierszach)."
      },
      {
        "category": "databases", "front": "Poziom izolacji: Snapshot",
        "back": "Wprowadzony np. w SQL Server 2005. Eliminuje blokowanie odczytÃ³w przez zapisy dziÄ™ki mechanizmowi wielowersyjnoÅ›ci (kopii starych wierszy w TempDB)."
      },
      {
        "category": "databases", "front": "Sterowanie transakcjami (SQL)",
        "back": "BEGIN TRANSACTION (start), COMMIT (trwaÅ‚e zatwierdzenie), ROLLBACK (wycofanie zmian do poczÄ…tku lub punktu SAVEPOINT)."
      },
      {
        "category": "databases", "front": "Dobre praktyki pisania transakcji",
        "back": "Powinny byÄ‡ jak najkrÃ³tsze, obejmowaÄ‡ peÅ‚ne operacje biznesowe, a poziomy izolacji nie powinny byÄ‡ podbijane 'na zapas', by nie psuÄ‡ wydajnoÅ›ci."
      },
      {
        "category": "databases", "front": "JÄ™zyk SQL (Pochodzenie i charakterystyka)",
        "back": "Standard ISO od 1986. JÄ™zyk deklaratywny: uÅ¼ytkownik okreÅ›la, CO chce uzyskaÄ‡, a silnik (SZBD) sam decyduje, JAK to najszybciej zrobiÄ‡."
      },
      {
        "category": "databases", "front": "Operatory logiczne i porÃ³wnania w SQL",
        "back": "Logiczne: AND, OR, NOT. PorÃ³wnania: =, <>, >, LIKE (wzorzec tekstu z % i _), BETWEEN, IN, IS NULL."
      },
      {
        "category": "databases", "front": "Predykaty EXISTS i NOT EXISTS",
        "back": "SÅ‚uÅ¼Ä… do sprawdzania, czy podzapytanie zwraca jakiekolwiek wiersze (czÄ™sto duÅ¼o szybsze i bezpieczniejsze niÅ¼ uÅ¼ywanie operatora IN przy wartoÅ›ciach NULL)."
      },
      {
        "category": "databases", "front": "Dlaczego SQL jest wydajny? (Set-based vs Kursor)",
        "back": "SQL jest zoptymalizowany pod operacje zbiorowe (set-based) na caÅ‚ych tabelach. UÅ¼ywanie pÄ™tli (kursorÃ³w) po stronie serwera to antywzorzec wydajnoÅ›ciowy."
      },
      {
        "category": "databases", "front": "Struktura indeksÃ³w (B+drzewo)",
        "back": "ZrÃ³wnowaÅ¼one drzewo wielodrogowe, w ktÃ³rym poruszamy siÄ™ od korzenia przez wÄ™zÅ‚y poÅ›rednie aÅ¼ do liÅ›ci, aby szybko odszukaÄ‡ fizyczny adres rekordu."
      },
      {
        "category": "databases", "front": "Indeks zÅ‚oÅ¼ony",
        "back": "ZakÅ‚adany na wiÄ™cej niÅ¼ jednÄ… kolumnÄ™ (np. ImiÄ™ + Nazwisko). KolejnoÅ›Ä‡ kolumn w jego definicji jest kluczowa dla moÅ¼liwoÅ›ci jego wykorzystania przez silnik."
      },
      {
        "category": "databases", "front": "Kiedy WARTO tworzyÄ‡ indeksy?",
        "back": "Na kluczach gÅ‚Ã³wnych i obcych, oraz na kolumnach czÄ™sto wystÄ™pujÄ…cych w klauzulach WHERE, JOIN, ORDER BY, GROUP BY i DISTINCT."
      },
      {
        "category": "databases", "front": "Optymalizacja: JOIN vs Podzapytania",
        "back": "JeÅ›li to tylko moÅ¼liwe, naleÅ¼y unikaÄ‡ wielokrotnych, zagnieÅ¼dÅ¼onych podzapytaÅ„ na rzecz standardowych zÅ‚Ä…czeÅ„ (JOIN), ktÃ³re silnik potrafi lepiej zoptymalizowaÄ‡."
      },
      {
      "front": "Kohezja (SpÃ³jnoÅ›Ä‡)",
      "back": "OkreÅ›la, jak bardzo klasa skupia siÄ™ na swoim jednym, konkretnym zadaniu. W dobrym kodzie powinna byÄ‡ wysoka.",
      "category": "programing"
    },
    {
      "front": "Coupling (SprzÄ™Å¼enie)",
      "back": "ZaleÅ¼noÅ›Ä‡ klas od siebie nawzajem. Powinien byÄ‡ niski â€“ im mniej klasa wie o dziaÅ‚aniu innych, tym Å‚atwiej utrzymaÄ‡ kod.",
      "category": "programing"
    },
    {
      "front": "Miara abstrakcji",
      "back": "Odnosi siÄ™ do tego, ile zbÄ™dnych, trudnych szczegÃ³Å‚Ã³w technicznych potrafisz ukryÄ‡ pod prostymi w uÅ¼yciu interfejsami.",
      "category": "programing"
    },
    {
      "front": "Connascence",
      "back": "StopieÅ„ powiÄ…zania elementÃ³w kodu. JeÅ›li modyfikacja pliku A zmusza CiÄ™ do aktualizacji pliku B, to wystÄ™puje miÄ™dzy nimi connascence.",
      "category": "programing"
    },
    {
      "front": "DRY (Don't Repeat Yourself)",
      "back": "Zasada mÃ³wiÄ…ca, aby nie kopiowaÄ‡ tego samego kodu, lecz wydzielaÄ‡ powtarzajÄ…ce siÄ™ fragmenty do reuÅ¼ywalnych metod.",
      "category": "programing"
    },
    {
      "front": "YAGNI (You Aren't Gonna Need It)",
      "back": "Nie pisz funkcji \"na zapas\". Implementuj tylko to, czego wymaga aktualne zadanie.",
      "category": "programing"
    },
    {
      "front": "SOLID: SRP (Single Responsibility Principle)",
      "back": "Zasada pojedynczej odpowiedzialnoÅ›ci â€“ kaÅ¼da klasa powinna odpowiadaÄ‡ tylko za jedno konkretne zadanie.",
      "category": "programing"
    },
    {
      "front": "SOLID: OCP (Open/Closed Principle)",
      "back": "Kod powinien byÄ‡ otwarty na rozbudowÄ™ (dodawanie nowych funkcji), ale zamkniÄ™ty na modyfikacje (bez edytowania istniejÄ…cego kodu).",
      "category": "programing"
    },
    {
      "front": "SOLID: LSP (Liskov Substitution Principle)",
      "back": "Klasa dziedziczÄ…ca nie moÅ¼e Å‚amaÄ‡ zachowaÅ„ klasy bazowej; musi mÃ³c jÄ… bezproblemowo zastÄ…piÄ‡.",
      "category": "programing"
    },
    {
      "front": "SOLID: ISP (Interface Segregation Principle)",
      "back": "Lepiej tworzyÄ‡ wiele maÅ‚ych, wyspecjalizowanych interfejsÃ³w zamiast jednego duÅ¼ego i ogÃ³lnego.",
      "category": "programing"
    },
    {
      "front": "SOLID: DIP (Dependency Inversion Principle)",
      "back": "Kod powinien zaleÅ¼eÄ‡ od abstrakcji (np. interfejsÃ³w), a nie od konkretnych, sztywnych implementacji.",
      "category": "programing"
    },
    {
      "front": "Metoda AAA w testach",
      "back": "Å»elazna zasada 3 krokÃ³w: Arrange (przygotuj dane), Act (wywoÅ‚aj metodÄ™), Assert (sprawdÅº wynik).",
      "category": "programing"
    },
    {
      "front": "Piramida testÃ³w",
      "back": "Strategia testowania: najwiÄ™cej powinno byÄ‡ tanich testÃ³w jednostkowych (podstawa), mniej integracyjnych, a najmniej ciÄ™Å¼kich testÃ³w E2E (wierzchoÅ‚ek).",
      "category": "programing"
    },
    {
      "front": "Testy biaÅ‚oskrzynkowe vs czarnoskrzynkowe",
      "back": "BiaÅ‚oskrzynkowe: tester zna i widzi wewnÄ™trzny kod metody. Czarnoskrzynkowe: tester wpisuje tylko dane wejÅ›ciowe i sprawdza wynik, nie znajÄ…c kodu.",
      "category": "programing"
    },
    {
      "front": "3 sposoby przekazywania danych do REST API",
      "back": "1. ÅšcieÅ¼ka URL (route parameter). 2. Query string (?klucz=wartosc). 3. CiaÅ‚o Å¼Ä…dania (body, najczÄ™Å›ciej JSON w POST/PUT).",
      "category": "programing"
    },
    {
      "front": "Architektura REST",
      "back": "Bezstanowa architektura klient-serwer. Endpointy projektuje siÄ™ jako zasoby (rzeczowniki), a akcje na nich wykonuje metodami HTTP (GET, POST, PUT, DELETE).",
      "category": "programing"
    },
    {
      "front": "GraphQL",
      "back": "Alternatywa dla REST, w ktÃ³rej to klient definiuje dokÅ‚adnie, jakie pola i dane chce pobraÄ‡ w jednym zapytaniu.",
      "category": "programing"
    },
    {
      "front": "Zabezpieczenie przed SQL Injection",
      "back": "Stosowanie sparametryzowanych zapytaÅ„ (np. klasy SqlParameter). TraktujÄ… one dane od uÅ¼ytkownika zawsze jako wartoÅ›ci, a nie jako kod SQL.",
      "category": "programing"
    },
    {
      "front": "AsynchronicznoÅ›Ä‡ (async/await) w webÃ³wce",
      "back": "Zapobiega blokowaniu wÄ…tkÃ³w. Kiedy system czeka np. na bazÄ™ danych, uwalnia wÄ…tek dla innych Å¼Ä…daÅ„. Chroni to serwer przed wyczerpaniem puli wÄ…tkÃ³w i zawieszeniem.",
      "category": "programing"
    },
    {
      "front": "Task w asynchronicznoÅ›ci",
      "back": "Obiekt reprezentujÄ…cy asynchronicznÄ… operacjÄ™ â€“ dziaÅ‚a jak obietnica (promise), Å¼e wynik pojawi siÄ™ w przyszÅ‚oÅ›ci. Task<T> dodatkowo niesie zwracanÄ… wartoÅ›Ä‡.",
      "category": "programing"
    },
    {
      "front": "Transakcje w bazach danych",
      "back": "Mechanizm \"wszystko albo nic\". Zmiany sÄ… trwale zapisywane (Commit) lub w caÅ‚oÅ›ci wycofywane w razie bÅ‚Ä™du (Rollback).",
      "category": "programing"
    },
    {
      "front": "SkÅ‚adnia LINQ: Method syntax vs Query syntax",
      "back": "Method: nowoczeÅ›niejsze Å‚aÅ„cuchy metod z lambdami (np. lista.Where(x => ...)). Query: przypomina wizualnie SQL (from x in...).",
      "category": "programing"
    },
    {
      "front": "EF Core: Code First vs Database First",
      "back": "Code First: najpierw piszesz klasy C#, a EF generuje bazÄ™. Database First: najpierw baza, z ktÃ³rej EF automatycznie generuje modele C#.",
      "category": "programing"
    },
    {
      "front": "Migracje (EF Core)",
      "back": "Mechanizm Å›ledzenia zmian w schemacie bazy w modelu Code First. Tworzy skrypty SQL aktualizujÄ…ce bazÄ™ bez utraty danych (polecenia: migrations add / database update).",
      "category": "programing"
    },
    {
      "front": "Obiekty DTO (Data Transfer Object)",
      "back": "Proste klasy pozbawione logiki sÅ‚uÅ¼Ä…ce do przesyÅ‚ania danych miÄ™dzy warstwami, np. by odciÄ…Ä‡ wraÅ¼liwe informacje (jak hasÅ‚o) przed wysÅ‚aniem na frontend.",
      "category": "programing"
    },
    {
      "front": "MPA vs SPA (Architektura frontendu)",
      "back": "MPA (Cienki klient): serwer renderuje caÅ‚y HTML po kaÅ¼dym klikniÄ™ciu (lepsze SEO). SPA (Gruby klient): aplikacja Å‚aduje siÄ™ raz i wymienia tylko JSON-y przez API (lepszy UX).",
      "category": "programing"
    },
    {
      "front": "WspÃ³Å‚bieÅ¼noÅ›Ä‡: Lost Update vs Inconsistent Reads",
      "back": "Lost Update (zgubiona aktualizacja): nadpisanie sobie nawzajem zapisÃ³w. Inconsistent Reads: odczyt danych, ktÃ³re inna transakcja wÅ‚aÅ›nie zmienia.",
      "category": "programing"
    },
    {
      "front": "Blokowanie Optymistyczne vs Pesymistyczne",
      "back": "Optymistyczne: sprawdza kolizje dopiero przy prÃ³bie zapisu (np. ConcurrencyCheck). Pesymistyczne: nakÅ‚ada twardÄ… blokadÄ™ na rekord juÅ¼ w momencie jego odczytu.",
      "category": "programing"
    },
    {
        "front": "Ekosystem .NET: CLR i kod IL",
        "back": "CLR (Common Language Runtime) to Å›rodowisko uruchomieniowe. Kod C# najpierw kompiluje siÄ™ do jÄ™zyka poÅ›redniego (IL), a potem kompilator JIT przerabia go w locie na kod maszynowy.",
        "category": "programing"
      },
      {
        "front": "ZÅ‚oÅ¼onoÅ›Ä‡ cyklomatyczna",
        "back": "Miara jakoÅ›ci i czytelnoÅ›ci kodu. OkreÅ›la, ile Å›cieÅ¼ek wykonania (np. warunkÃ³w if/else, pÄ™tli) upchniÄ™to w jednej metodzie. Im mniejsza, tym lepsza.",
        "category": "programing"
      },
      {
        "front": "Delegaty Action i Func (C#)",
        "back": "Gotowe typy delegatÃ³w wbudowane w .NET. Action przechowuje metodÄ™, ktÃ³ra nic nie zwraca (void). Func przechowuje metodÄ™ zwracajÄ…cÄ… konkretny typ danych.",
        "category": "programing"
      },
      {
        "front": "Minimal API (ASP.NET Core)",
        "back": "Lekki sposÃ³b tworzenia API pomijajÄ…cy ciÄ™Å¼kie kontrolery i MVC. Endpointy definiuje siÄ™ bezpoÅ›rednio za pomocÄ… wyraÅ¼eÅ„ lambda w pliku Program.cs.",
        "category": "programing"
      },
      {
        "front": "Content Negotiation (REST)",
        "back": "Mechanizm, w ktÃ³rym serwer respektuje Å¼Ä…danie klienta dotyczÄ…ce formatu odpowiedzi (np. klient prosi o XML w nagÅ‚Ã³wku Accept, choÄ‡ domyÅ›lnie jest to JSON).",
        "category": "programing"
      },
      {
        "front": "Metody rozszerzeÅ„ (Extension Methods)",
        "back": "PozwalajÄ… 'dokleiÄ‡' nowÄ… metodÄ™ do istniejÄ…cej klasy (nawet zamkniÄ™tej, jak string) bez zmiany jej kodu. Tworzy siÄ™ je jako statyczne metody w statycznej klasie z parametrem 'this'.",
        "category": "programing"
      },
      {
        "front": "Kontener IoC: Singleton",
        "back": "Cykl Å¼ycia zaleÅ¼noÅ›ci: jedna, ta sama instancja obiektu Å¼yje przez caÅ‚y czas dziaÅ‚ania aplikacji, od startu do jej wyÅ‚Ä…czenia.",
        "category": "programing"
      },
      {
        "front": "Kontener IoC: Scoped",
        "back": "Cykl Å¼ycia zaleÅ¼noÅ›ci: nowa instancja jest tworzona na kaÅ¼de nowe Å¼Ä…danie HTTP i Å¼yje tylko tak dÅ‚ugo, jak trwa obsÅ‚uga tego konkretnego requestu.",
        "category": "programing"
      },
      {
        "front": "Kontener IoC: Transient",
        "back": "Cykl Å¼ycia zaleÅ¼noÅ›ci: nowa instancja obiektu jest tworzona za absolutnie kaÅ¼dym razem, gdy jakikolwiek komponent o niÄ… poprosi.",
        "category": "programing"
      },
      {
        "front": "Horizontal vs Vertical Slice (Architektura)",
        "back": "Horizontal (warstwowa): podziaÅ‚ techniczny (foldery: Controllers, Services). Vertical (funkcjonalna): podziaÅ‚ na ficzery (folder 'Koszyk' ma swÃ³j wÅ‚asny kontroler, model i serwis w jednym miejscu).",
        "category": "programing"
      },
      {
        "front": "DAL vs BAL",
        "back": "DAL (Data Access Layer): warstwa dostÄ™pu do danych (infrastruktura, baza). BAL (Business Access Layer): warstwa logiki biznesowej (reguÅ‚y, obliczenia, decyzje).",
        "category": "programing"
      },
      {
        "front": "WÄ…tek vs Proces",
        "back": "Proces to osobna, ciÄ™Å¼ka aplikacja w systemie z izolowanÄ… pamiÄ™ciÄ…. WÄ…tek to lÅ¼ejsza jednostka wewnÄ…trz procesu â€“ wspÃ³Å‚dzieli pamiÄ™Ä‡ z innymi wÄ…tkami, co wymaga synchronizacji.",
        "category": "programing"
      },
      {
        "front": "CPU-bound vs I/O-bound",
        "back": "CPU-bound obciÄ…Å¼a procesor (np. kompresja, obliczenia matematyczne). I/O-bound czeka na ÅºrÃ³dÅ‚o zewnÄ™trzne (dysk, API, bazÄ™), procesor wtedy 'odpoczywa'.",
        "category": "programing"
      },
      {
        "front": "Architektura: Domain Model vs Transactional Script",
        "back": "Script: prosta metoda robocza bez bogatego modelu (pobierz-przelicz-zapisz). Domain Model: przeniesienie logiki do bogatych, samowalidujÄ…cych siÄ™ obiektÃ³w (odporniejsze na zmiany, ale trudniejsze na start).",
        "category": "programing"
      },
      {
        "front": "Wzorzec Unit of Work",
        "back": "Koordynuje wiele repozytoriÃ³w na raz. Zbiera wszystkie zmiany z rÃ³Å¼nych miejsc i wysyÅ‚a je do bazy danych w jednej transakcji za pomocÄ… pojedynczego SaveChanges().",
        "category": "programing"
      },
      {
        "front": "CancellationToken",
        "back": "Mechanizm pozwalajÄ…cy przerwaÄ‡ (anulowaÄ‡) asynchronicznÄ… operacjÄ™ na serwerze (np. zapytanie do bazy), gdy uÅ¼ytkownik zamknie przeglÄ…darkÄ™ przed otrzymaniem odpowiedzi.",
        "category": "programing"
      },
      {
        "front": "Middleware (ASP.NET Core)",
        "back": "Komponenty poÅ›redniczÄ…ce w potoku Å¼Ä…daÅ„ HTTP (pipeline). KaÅ¼de Å¼Ä…danie (oraz odpowiedÅº) przechodzi przez Å‚aÅ„cuch middleware'Ã³w (np. logowanie, CORS, uwierzytelnianie).",
        "category": "programing"
      },
      {
        "front": "Uwierzytelnianie vs Autoryzacja",
        "back": "Uwierzytelnianie (Authentication) to weryfikacja toÅ¼samoÅ›ci ('kim jesteÅ›?', logowanie). Autoryzacja (Authorization) to weryfikacja uprawnieÅ„ ('do czego masz dostÄ™p?', role).",
        "category": "programing"
      },
      {
        "front": "Szyfrowanie vs Kodowanie",
        "back": "Szyfrowanie ukrywa dane za pomocÄ… klucza i zapewnia poufnoÅ›Ä‡. Kodowanie (np. Base64) tylko zmienia format na potrzeby przesyÅ‚u â€“ kaÅ¼dy moÅ¼e to odkodowaÄ‡.",
        "category": "programing"
      },
      {
        "front": "Token JWT (Access vs Refresh)",
        "back": "Access Token: krÃ³tkotrwaÅ‚y, doÅ‚Ä…czany do Å¼Ä…daÅ„ (header Bearer). Refresh Token: dÅ‚ugotrwaÅ‚y, uÅ¼ywany wyÅ‚Ä…cznie do wygenerowania nowego Access Tokena po jego wygaÅ›niÄ™ciu.",
        "category": "programing"
      },
      {
        "front": "Wzorzec MVC w ASP.NET",
        "back": "Model (dane i logika biznesowa), View (szablon UI, HTML), Controller (przyjmuje Å¼Ä…danie od klienta, wywoÅ‚uje logikÄ™ i zwraca View).",
        "category": "programing"
      },
      {
        "front": "Silnik Razor",
        "back": "Pozwala osadzaÄ‡ kod C# bezpoÅ›rednio w szablonach HTML za pomocÄ… znaku @ (np. @foreach, @if), by dynamicznie generowaÄ‡ widoki z poziomu serwera.",
        "category": "programing"
      },
      {
        "front": "WebAssembly (WASM)",
        "back": "Standard pozwalajÄ…cy uruchamiaÄ‡ skompilowany kod z jÄ™zykÃ³w typu C#, C++ czy Rust bezpoÅ›rednio w przeglÄ…darce, zastÄ™pujÄ…c lub uzupeÅ‚niajÄ…c JavaScript.",
        "category": "programing"
      },
      {
        "front": "Blazor Server vs Blazor WebAssembly",
        "back": "Server: logika i renderowanie dziaÅ‚ajÄ… na serwerze, klient to tylko terminal na poÅ‚Ä…czeniu WebSocket (SignalR). WASM: caÅ‚a apka pobiera siÄ™ do przeglÄ…darki i dziaÅ‚a po stronie klienta (nawet offline).",
        "category": "programing"
      },
      {
        "front": "Test Doubles: Mock vs Spy",
        "back": "Oba to atrapy do testÃ³w. Mock sprawdza zachowanie (czy metoda w ogÃ³le zostaÅ‚a wywoÅ‚ana z konkretnymi parametrami). Spy po cichu rejestruje historiÄ™ wywoÅ‚aÅ„ do pÃ³Åºniejszej analizy.",
        "category": "programing"
      },
      {
        "front": "Test Doubles: Fake vs Stub vs Dummy",
        "back": "Fake: dziaÅ‚ajÄ…ca uproszczona kopia (np. In-Memory DB). Stub: zaÅ›lepka zwracajÄ…ca z gÃ³ry zaprogramowane na sztywno dane. Dummy: pusty obiekt przekazywany tylko po to, by speÅ‚niÄ‡ wymÃ³g sygnatury metody.",
        "category": "programing"
      },
      {
      "front": "Problem rozwiÄ…zywany przez .AsSplitQuery()",
      "back": "Zapobiega tzw. eksplozji kartezjaÅ„skiej (duplikacji wierszy) przy wielu .Include() na kolekcjach. Zamiast jednego gigantycznego zapytania z JOIN, generuje osobne mniejsze zapytania SQL.",
      "category": "programing"
    },
    {
      "front": ".AsNoTracking() w EF Core",
      "back": "WyÅ‚Ä…cza Å›ledzenie encji w pamiÄ™ci przez Change Tracker. Znacznie oszczÄ™dza pamiÄ™Ä‡ i procesor, idealne do zapytaÅ„ typu 'tylko do odczytu' (Read-Only).",
      "category": "programing"
    },
    {
      "front": "Konwersja .AsQueryable()",
      "back": "Zwraca interfejs IQueryable<T>, pozwalajÄ…cy na opÃ³Åºnione wykonanie zapytania (deferred execution). UmoÅ¼liwia dynamiczne i warunkowe budowanie zapytaÅ„ (np. doklejanie .Where() w instrukcjach IF).",
      "category": "programing"
    },
    {
      "front": "LINQ: .Where() vs .Select()",
      "back": ".Where() sÅ‚uÅ¼y do filtrowania wierszy (odpowiednik WHERE). .Select() sÅ‚uÅ¼y do projekcji/mapowania, np. wyciÄ…gania tylko konkretnych kolumn z bazy do obiektu DTO (odpowiednik SELECT).",
      "category": "programing"
    },
    {
      "front": "Paginacja w LINQ",
      "back": "Wykonuje siÄ™ jÄ… za pomocÄ… kombinacji metod .Skip(n) (odpowiednik SQL OFFSET) oraz .Take(m) (odpowiednik SQL LIMIT).",
      "category": "programing"
    },
    {
      "front": "LINQ: .SelectMany()",
      "back": "Metoda sÅ‚uÅ¼Ä…ca do spÅ‚aszczania zagnieÅ¼dÅ¼onych kolekcji. Zamienia np. listÄ™ list z obiektami w jednÄ…, pÅ‚askÄ… listÄ™ elementÃ³w.",
      "category": "programing"
    },
    {
      "front": "Kiedy zapytanie LINQ faktycznie trafia do bazy danych?",
      "back": "Dopiero w momencie uÅ¼ycia tzw. metod materializujÄ…cych, ktÃ³re przerywajÄ… budowanie query i wysyÅ‚ajÄ… SQL do bazy (np. .ToListAsync(), .FirstOrDefaultAsync(), .CountAsync()).",
      "category": "programing"
    },
    {
      "front": ".SingleOrDefaultAsync() vs .FirstOrDefaultAsync()",
      "back": "SingleOrDefault oczekuje dokÅ‚adnie 0 lub 1 wyniku â€“ jeÅ›li znajdzie wiÄ™cej, rzuci wyjÄ…tek (uÅ¼ywane przy unikalnych kluczach). FirstOrDefault bezpiecznie weÅºmie pierwszy z brzegu wynik, ignorujÄ…c resztÄ™.",
      "category": "programing"
    },
    {
      "front": ".FindAsync(key) w EF Core",
      "back": "Szuka encji najpierw w pamiÄ™ci podrÄ™cznej (Change Trackerze), a dopiero potem uderza do bazy danych. Jest szybkie, ale nie obsÅ‚uguje doÅ‚Ä…czania relacji przez .Include().",
      "category": "programing"
    },
    {
      "front": "Metody .AddAsync(), .Update(), .Remove()",
      "back": "Nie wysyÅ‚ajÄ… one od razu komend SQL do bazy. ZmieniajÄ… jedynie stan danej encji w pamiÄ™ci RAM (w mechanizmie Change Tracker).",
      "category": "programing"
    },
    {
      "front": ".SaveChangesAsync()",
      "back": "Zatwierdza wszystkie oczekujÄ…ce modyfikacje zebrane w Change Trackerze. Dopiero ta metoda generuje i wysyÅ‚a komendy INSERT, UPDATE, DELETE w ramach jednej transakcji w bazie.",
      "category": "programing"
    },
    {
      "front": "LINQ: .AnyAsync()",
      "back": "Odpowiednik SQL EXISTS. SÅ‚uÅ¼y do bardzo wydajnego sprawdzenia, czy w bazie istnieje jakikolwiek rekord speÅ‚niajÄ…cy podany warunek (zwraca po prostu wartoÅ›Ä‡ boolean).",
      "category": "programing"
    },
    {
      "front": "LINQ: .Join()",
      "back": "ZÅ‚Ä…czenie tabel (odpowiednik INNER JOIN). ÅÄ…czy dwa zbiory na podstawie wspÃ³lnego klucza (czÄ™sto uÅ¼ywane do mapowania DTO zamiast .Include()).",
      "category": "programing"
    },
    {
      "front": "LINQ: .GroupBy()",
      "back": "Grupuje elementy po wskazanym kluczu. Jest to dokÅ‚adny odpowiednik klauzuli GROUP BY z jÄ™zyka SQL.",
      "category": "programing"
    },
    {
      "front": "LINQ: .Distinct()",
      "back": "Usuwa duplikaty z kolekcji wynikÃ³w (odpowiednik SQL DISTINCT). Zwraca unikalne wartoÅ›ci.",
      "category": "programing"
    },
    {
      "front": "LINQ: .OrderBy() oraz .OrderByDescending()",
      "back": "SÅ‚uÅ¼Ä… do sortowania danych. Pierwsza sortuje rosnÄ…co, druga malejÄ…co (odpowiednik SQL ORDER BY).",
      "category": "programing"
    },
    {
      "front": "Metoda .CountAsync() w EF Core",
      "back": "Metoda materializujÄ…ca zapytanie. WysyÅ‚a do bazy SQL typu 'SELECT COUNT(...)' i zwraca liczbÄ™ elementÃ³w (int). JeÅ›li baza jest pusta, bezpiecznie zwraca 0.",
      "category": "programing"
    },
    {
      "front": "PrawidÅ‚owy, logiczny ciÄ…g zapytania w EF Core (KolejnoÅ›Ä‡)",
      "back": "1. Å¹rÃ³dÅ‚o (DbSet) -> 2. Relacje (Include) -> 3. Opcje (NoTracking) -> 4. Filtrowanie (Where) -> 5. Mapowanie (Select) -> 6. Sortowanie (OrderBy) -> 7. Paginacja (Skip/Take) -> 8. Materializacja (np. ToListAsync).",
      "category": "programing"
    }
    ]
  }